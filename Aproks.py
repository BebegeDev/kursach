import matplotlib.pyplot as pl
import numpy as np
import pandas as pd
from scipy.optimize import curve_fit

# ---------------------------------------------------------------------------------------------------------------------|
# ---------------------------------------FunctionApproximation---------------------------------------------------------|
# ---------------------------------------------------------------------------------------------------------------------|
'''
Класс для оптимизации и аппроксимации по точкам:
+ провести сравнение с интерполяцией 
+ почитать документацию про сплайны (ответ по теме на форуме)

Состав методов и атрибутов:
Инициализатор
func - получает массив данных с мощностью, возвращает примерный вид функции.
Для оптимизации и подбора коэффициентов.
args_mapping - оптимизирует и и распаковывает коэффициенты. См. mapping работает так же по условию регрессии 
mapping - отображение графика. Из-за разности регрессии делаем условие для каждого вида регрессии (всего два:
квадратичная условие n == 1 и кубическая условие n == 2)
'''


class FunctionApproximation:
    # Инициализатор принимает значения для оси х и у
    def __init__(self, N, ny):
        self.new_ny = ny
        self.N = N
        self.ny = ny

    # Статический метод возвращает квадратичную регрессию
    @staticmethod
    def func_1(N, a, b, c):
        return -a * N ** 2 + b * N + c

    # Статический метод возвращает кубическую регрессию
    @staticmethod
    def func_2(N, a, b, c, d):
        return a * N ** 3 - (b * N ** 2) + (c * N + d)

    # Метод для получения коэф-ов
    def args_mapping(self, n=1):
        # Условный оператор предназначен для ветвления в зависимости от корреляции
        toplot = np.arange(min(self.N), max(self.N))
        # Условный оператор предназначен для ветвления в зависимости от корреляции
        if n == 1:
            args, covar = curve_fit(FunctionApproximation.func_1, self.N, self.ny)
            f = FunctionApproximation.func_1(toplot, *args)
        else:
            args, covar = curve_fit(FunctionApproximation.func_2, self.N, self.ny)
            f = FunctionApproximation.func_2(toplot, *args)
        return toplot, f

    # Метод для получения графиков
    def mapping(self, *args):
        if len(args) != 1:
            n, new_N, new_dN, N, dN = args
        else:
            n = args[0]
        dict_y = {1: 'ny, %', 2: 'dN, МВт'}
        fig, ax = pl.subplots()
        if n == 1:
            ax.plot(self.N, self.ny, 'bo', label='data')
            ax.plot(self.args_mapping(n)[0], self.args_mapping(n)[1], '-', label='fit')
        elif n == 2:
            ax.plot(N, dN, 'bo', label='data')
            ax.plot(new_N, new_dN, '-', label='fit')
        pl.xlabel("N, МВт")
        pl.ylabel(dict_y[n])
        pl.grid()
        pl.legend()
        pl.show()

    # def test(self, x, y):
    #     xx = x
    #     yy = y
    #     d = 3
    #     fp, residuals, rank, sv, rcond = np.polyfit(x, y, d, full=True)
    #     f = np.polyfit(xx, yy, deg=3)  # аппроксимирующая функция
    #     # print('Коэффициент -- a %s  ' % round(fp[0], 4))
    #     # print('Коэффициент-- b %s  ' % round(fp[1], 4))
    #     # print('Коэффициент -- c %s  ' % round(fp[2], 4))
    #     y1 = [fp[0] * x[i] ** 2 + fp[1] * x[i] + fp[2] for i in range(0, len(x))]  # значения функции a*x**2+b*x+c
    #     so = round(sum([abs(y[i] - y1[i]) for i in range(0, len(x))]) / (len(x) * sum(y)) * 100, 4)  # средняя ошибка
    #     print('Average quadratic deviation ' + str(so))
    #     fx = np.arange(min(x), max(x)) # можно установить вместо len(x) большее число для интерполяции
    #     pl.plot(xx, yy, label='Original data', markersize=10)
    #     pl.plot(fx, f(fx), linewidth=2)
    #     pl.grid(True)
    #     pl.show()


'''
Вывод (без правок см. описание класса):
промежуточные значения можно получить по графику (мышкой), можно сравнить с excel
'''


# ---------------------------------------------------------------------------------------------------------------------|
# ---------------------------------------SaveXlcx----------------------------------------------------------------------|
# ---------------------------------------------------------------------------------------------------------------------|

class SaveXlcx:
    # Получение Массива данных для excel
    def __init__(self, new_N, new_ny, new_dN, N, ny, dN, Q):
        self.new_N = new_N
        self.new_ny = new_ny
        self.new_dN = new_dN
        self.N = N
        self.ny = ny
        self.dN = dN
        self.Q = Q

    def writer(self, flag):
        data = {'new_N': self.new_N, 'new_ny': self.new_ny, 'new_dN': self.new_dN, 'Q': self.Q, 'N': self.N,
                'ny': self.ny,
                'dN': self.dN}
        data = pd.DataFrame(data)
        if flag == '0':
            wr = pd.ExcelWriter('OUT_ter.xlsx')
        elif flag == '1':
            wr = pd.ExcelWriter('OUT_zav.xlsx')
        data.to_excel(wr)
        wr.save()


# ---------------------------------------------------------------------------------------------------------------------|
# ---------------------------------------------------------------------------------------------------------------------|
# ---------------------------------------------------------------------------------------------------------------------|


def main():
    print(f'Выберете теоритические ({0}) или заводские ({1}) характеристики')
    flag = input()
    print('Поместите файл excel (названия файла по шаблону) в папку со скриптом.')
    print('Выгрузите (по шаблону) данные по вашему напору H.')
    print('Введите напор')
    H = float(input())
    print('Нумерация с 0. Лист 0: 7 агрегат, Лист 1: 8 агрегат, Лист 3: 9 агрегат, Лист 4: 10 агрегат')
    print('Введите номер листа')
    sheet_number = int(input())

    # -----------------------------------------------------------------------------------------------------------------|
    def open_file(xls):
        df = xls.parse(sheet_number)
        data = pd.DataFrame(df)
        return data

    # -----------------------------------------------------------------------------------------------------------------|
    '''
    Для рабочей характеристики.
    Работает по принципу, нахождения прихода мощности на 0.1 м (h = у.е.). Т.о. получаем что мощность в данной точке будет равна
    как кол-во h умноженное на разницу мощностей поделеное на десять (для получения мощности равной одной h).
    '''
    # Для рабочей характеристики
    if flag == '1':
        print('Введите смежные напоры по отношению к вашему, где Н1 минимальный, Н2 максимальный ')

        H1, H2 = [int(input('H1: '))] * 100, [int(input('H2: '))] * 100
        xls = pd.ExcelFile('agregat_rab.xlsx')
        data = open_file(xls)
        # Константы
        H = [H] * 100
        N_H1 = data['N_H1'] / 1000
        N_H2 = data['N_H2'] / 1000
        N = pd.Series(map(lambda N_H1, N_H2, H1, H: ((N_H2 - N_H1) / 10) * ((H - H1) * 10) + N_H1, N_H1, N_H2, H1, H))
        print(N)
    # Для теоритической характеристики
    elif flag == '0':
        xls = pd.ExcelFile('agregat.xlsx')
        data = open_file(xls)
        # Константы
        H = [H] * 100
        N = data['N'] / 1000
    ny = data['ny']
    # -----------------------------------------------------------------------------------------------------------------|
    # ---------------------------------------ЛОКАЛКА-------------------------------------------------------------------|
    # -----------------------------------------------------------------------------------------------------------------|
    # (разнести если станет разрастаться)
    '''
    df, data - чтение и выделение таблицы в DataFrame
    H - напор по условию 20.8 (пробую пока с 20)
    N - тип Series из DataFrame, хранит в себе одномерный массив мощности
    ny - тип Series из DataFrame, хранит в себе одномерный массив КПД
    dN - дельта N
    Q - расход
    '''
    # -----------------------------------------------------------------------------------------------------------------|
    # Создание одномерных массивов данных
    dN = pd.Series(map(lambda N, ny: N * (100 - ny) / ny, N, ny))
    # -----------------------------------------------------------------------------------------------------------------|
    # Создание ЭК класса FunctionApproximation (N, ny)
    args_N_ny = FunctionApproximation(N, ny)
    # -----------------------------------------------------------------------------------------------------------------|
    # Получение новых значений КПД и N после оптимизации
    new_ny = args_N_ny.args_mapping()[1]
    new_N = args_N_ny.args_mapping()[0]
    # -----------------------------------------------------------------------------------------------------------------|
    # Расчет dN по новым занчениям КПД
    new_dN = pd.Series(map(lambda N, ny: N * (100 - ny) / ny, new_N, new_ny))
    Q = pd.Series(map(lambda N, ny, H: N / (H * 9.81 * ny / 100), new_N, new_ny, H))
    # -----------------------------------------------------------------------------------------------------------------|
    # Вызов метода класса для отображения графиков
    args_N_ny.mapping(1)
    args_N_ny.mapping(2, new_N, new_dN, N, dN)
    # -----------------------------------------------------------------------------------------------------------------|
    # Создание ЭК класса SaveXlcx
    excel_7 = SaveXlcx(new_N, new_ny, new_dN, N, ny, dN, Q)
    # -----------------------------------------------------------------------------------------------------------------|
    # Вызов метода для сохранения файла excel
    excel_7.writer(flag)
    # -----------------------------------------------------------------------------------------------------------------|
    # args_N_ny.test(N, ny)


if __name__ == "__main__":
    main()
